/* eslint-disable */
/**
 * Generated by orval üç∫
 * Do not edit manually.
 * JSONPlaceholder API
 * Free fake REST API for testing and prototyping
 * OpenAPI spec version: 1.0.0
 */
import {useMutation, useQuery, useSuspenseQuery} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query'

import type {
  GetTodosParams,
  Todo,
  TodoInput,
  TodoPatch,
} from './api.generated.schemas'

import {axiosInstance} from '../axios'
import type {ErrorType, BodyType} from '../axios'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Returns a list of todos
 * @summary Get all todos
 */
export const getTodos = (
  params?: GetTodosParams,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Todo[]>(
    {url: `/todos`, method: 'GET', params, signal},
    options,
  )
}

export const getGetTodosQueryKey = (params?: GetTodosParams) => {
  return [`/todos`, ...(params ? [params] : [])] as const
}

export const getGetTodosQueryOptions = <
  TData = Awaited<ReturnType<typeof getTodos>>,
  TError = ErrorType<unknown>,
>(
  params?: GetTodosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTodos>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTodosQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodos>>> = ({
    signal,
  }) => getTodos(params, requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getTodos>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>}
}

export type GetTodosQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTodos>>
>
export type GetTodosQueryError = ErrorType<unknown>

export function useGetTodos<
  TData = Awaited<ReturnType<typeof getTodos>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | GetTodosParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTodos>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodos>>,
          TError,
          Awaited<ReturnType<typeof getTodos>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTodos<
  TData = Awaited<ReturnType<typeof getTodos>>,
  TError = ErrorType<unknown>,
>(
  params?: GetTodosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTodos>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodos>>,
          TError,
          Awaited<ReturnType<typeof getTodos>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>}
export function useGetTodos<
  TData = Awaited<ReturnType<typeof getTodos>>,
  TError = ErrorType<unknown>,
>(
  params?: GetTodosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTodos>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>}
/**
 * @summary Get all todos
 */

export function useGetTodos<
  TData = Awaited<ReturnType<typeof getTodos>>,
  TError = ErrorType<unknown>,
>(
  params?: GetTodosParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTodos>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetTodosQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>}

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetTodosSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTodos>>,
  TError = ErrorType<unknown>,
>(
  params?: GetTodosParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTodos>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTodosQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodos>>> = ({
    signal,
  }) => getTodos(params, requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTodos>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>}
}

export type GetTodosSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTodos>>
>
export type GetTodosSuspenseQueryError = ErrorType<unknown>

export function useGetTodosSuspense<
  TData = Awaited<ReturnType<typeof getTodos>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | GetTodosParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTodos>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTodosSuspense<
  TData = Awaited<ReturnType<typeof getTodos>>,
  TError = ErrorType<unknown>,
>(
  params?: GetTodosParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTodos>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTodosSuspense<
  TData = Awaited<ReturnType<typeof getTodos>>,
  TError = ErrorType<unknown>,
>(
  params?: GetTodosParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTodos>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get all todos
 */

export function useGetTodosSuspense<
  TData = Awaited<ReturnType<typeof getTodos>>,
  TError = ErrorType<unknown>,
>(
  params?: GetTodosParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTodos>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetTodosSuspenseQueryOptions(params, options)

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a new todo
 * @summary Create a new todo
 */
export const createTodo = (
  todoInput: BodyType<TodoInput>,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Todo>(
    {
      url: `/todos`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: todoInput,
      signal,
    },
    options,
  )
}

export const getCreateTodoMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTodo>>,
    TError,
    {data: BodyType<TodoInput>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTodo>>,
  TError,
  {data: BodyType<TodoInput>},
  TContext
> => {
  const mutationKey = ['createTodo']
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTodo>>,
    {data: BodyType<TodoInput>}
  > = (props) => {
    const {data} = props ?? {}

    return createTodo(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateTodoMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTodo>>
>
export type CreateTodoMutationBody = BodyType<TodoInput>
export type CreateTodoMutationError = ErrorType<unknown>

/**
 * @summary Create a new todo
 */
export const useCreateTodo = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTodo>>,
      TError,
      {data: BodyType<TodoInput>},
      TContext
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTodo>>,
  TError,
  {data: BodyType<TodoInput>},
  TContext
> => {
  const mutationOptions = getCreateTodoMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Returns a single todo
 * @summary Get a todo by ID
 */
export const getTodoById = (
  id: number,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Todo>(
    {url: `/todos/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetTodoByIdQueryKey = (id?: number) => {
  return [`/todos/${id}`] as const
}

export const getGetTodoByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getTodoById>>,
  TError = ErrorType<null>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTodoById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTodoByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodoById>>> = ({
    signal,
  }) => getTodoById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getTodoById>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>}
}

export type GetTodoByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTodoById>>
>
export type GetTodoByIdQueryError = ErrorType<null>

export function useGetTodoById<
  TData = Awaited<ReturnType<typeof getTodoById>>,
  TError = ErrorType<null>,
>(
  id: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTodoById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodoById>>,
          TError,
          Awaited<ReturnType<typeof getTodoById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTodoById<
  TData = Awaited<ReturnType<typeof getTodoById>>,
  TError = ErrorType<null>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTodoById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodoById>>,
          TError,
          Awaited<ReturnType<typeof getTodoById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>}
export function useGetTodoById<
  TData = Awaited<ReturnType<typeof getTodoById>>,
  TError = ErrorType<null>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTodoById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>}
/**
 * @summary Get a todo by ID
 */

export function useGetTodoById<
  TData = Awaited<ReturnType<typeof getTodoById>>,
  TError = ErrorType<null>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTodoById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetTodoByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>}

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetTodoByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTodoById>>,
  TError = ErrorType<null>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTodoById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTodoByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodoById>>> = ({
    signal,
  }) => getTodoById(id, requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTodoById>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>}
}

export type GetTodoByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTodoById>>
>
export type GetTodoByIdSuspenseQueryError = ErrorType<null>

export function useGetTodoByIdSuspense<
  TData = Awaited<ReturnType<typeof getTodoById>>,
  TError = ErrorType<null>,
>(
  id: number,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTodoById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTodoByIdSuspense<
  TData = Awaited<ReturnType<typeof getTodoById>>,
  TError = ErrorType<null>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTodoById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetTodoByIdSuspense<
  TData = Awaited<ReturnType<typeof getTodoById>>,
  TError = ErrorType<null>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTodoById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get a todo by ID
 */

export function useGetTodoByIdSuspense<
  TData = Awaited<ReturnType<typeof getTodoById>>,
  TError = ErrorType<null>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTodoById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetTodoByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Updates an existing todo (replaces all fields)
 * @summary Update a todo
 */
export const updateTodo = (
  id: number,
  todoInput: BodyType<TodoInput>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Todo>(
    {
      url: `/todos/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: todoInput,
    },
    options,
  )
}

export const getUpdateTodoMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTodo>>,
    TError,
    {id: number; data: BodyType<TodoInput>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTodo>>,
  TError,
  {id: number; data: BodyType<TodoInput>},
  TContext
> => {
  const mutationKey = ['updateTodo']
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTodo>>,
    {id: number; data: BodyType<TodoInput>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateTodo(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateTodoMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTodo>>
>
export type UpdateTodoMutationBody = BodyType<TodoInput>
export type UpdateTodoMutationError = ErrorType<unknown>

/**
 * @summary Update a todo
 */
export const useUpdateTodo = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTodo>>,
      TError,
      {id: number; data: BodyType<TodoInput>},
      TContext
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTodo>>,
  TError,
  {id: number; data: BodyType<TodoInput>},
  TContext
> => {
  const mutationOptions = getUpdateTodoMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Updates specific fields of an existing todo
 * @summary Partially update a todo
 */
export const patchTodo = (
  id: number,
  todoPatch: BodyType<TodoPatch>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Todo>(
    {
      url: `/todos/${id}`,
      method: 'PATCH',
      headers: {'Content-Type': 'application/json'},
      data: todoPatch,
    },
    options,
  )
}

export const getPatchTodoMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchTodo>>,
    TError,
    {id: number; data: BodyType<TodoPatch>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchTodo>>,
  TError,
  {id: number; data: BodyType<TodoPatch>},
  TContext
> => {
  const mutationKey = ['patchTodo']
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchTodo>>,
    {id: number; data: BodyType<TodoPatch>}
  > = (props) => {
    const {id, data} = props ?? {}

    return patchTodo(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type PatchTodoMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchTodo>>
>
export type PatchTodoMutationBody = BodyType<TodoPatch>
export type PatchTodoMutationError = ErrorType<unknown>

/**
 * @summary Partially update a todo
 */
export const usePatchTodo = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchTodo>>,
      TError,
      {id: number; data: BodyType<TodoPatch>},
      TContext
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchTodo>>,
  TError,
  {id: number; data: BodyType<TodoPatch>},
  TContext
> => {
  const mutationOptions = getPatchTodoMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Deletes a todo
 * @summary Delete a todo
 */
export const deleteTodo = (
  id: number,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<null>({url: `/todos/${id}`, method: 'DELETE'}, options)
}

export const getDeleteTodoMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTodo>>,
    TError,
    {id: number},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTodo>>,
  TError,
  {id: number},
  TContext
> => {
  const mutationKey = ['deleteTodo']
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTodo>>,
    {id: number}
  > = (props) => {
    const {id} = props ?? {}

    return deleteTodo(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteTodoMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTodo>>
>

export type DeleteTodoMutationError = ErrorType<unknown>

/**
 * @summary Delete a todo
 */
export const useDeleteTodo = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTodo>>,
      TError,
      {id: number},
      TContext
    >
    request?: SecondParameter<typeof axiosInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTodo>>,
  TError,
  {id: number},
  TContext
> => {
  const mutationOptions = getDeleteTodoMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
